### 说一说你对数据库事务的了解
事务中的操作，要么都执行修改，要么都不执行,具有4个特性 原子性（要么全成功，要么全失败回滚），
一致性（一种状态转变为另一种一致的状态，所有事务对一个数据的读取结果都是相同的），
隔离性（一个事务对另一个事务不能产生影响），
持久性（事务提交成功后，改变是永久的）。
### 数据库的隔离级别
1.读未提交
2.读提交
3.可重复读
4.串行化
### 并发情况下，读操作可能存在的三类问题：
<br />1.脏读：一个事务读取的被是另一个事务修改的脏数据
<br />2.不可重复读：2次相同条件读取的结果不一致，一般是update
<br />3.幻读：当同一查询多次执行时，由于其它事务在这个数据范围内执行了插入操作，会导致每次返回不同的结果集;insert
### 乐观锁 悲观锁
<br> 乐观锁：想他的名字一样是非常乐观的，他一般认为操作数据时不会对数据进行修改，但对数据进行修改时会判断这个期间数据是否修改过，如果修改过则进行更新，然后修改。
适合读多写少   CAS
<br> 悲观锁：认为数据随时会被修改，所以对于数据的每次操作都会加上锁，在他释放锁之前其他事务都不能对数据进行操作。适合频繁更新操作
### 常见锁的类型,以及锁的粒度，锁有什么用
用于管理对共享资源的并发访问，保证数据库的完整性和一致性<br>
排它锁（Exclusive Lock）/ X锁：事务对数据加上X锁时，只允许此事务读取和修改此数据，并且其它事务不能对该数据加任何锁；
<br>共享锁（Shared Lock）/ S锁：加了S锁后，该事务只能对数据进行读取而不能修改，并且其它事务只能加S锁，不能加X锁<br>
行级锁：对操作的行进行加锁<br>
表级锁:对整个表进行加锁
### MVCC
多版本并发控制协议   在使用RC（读已提交）以及RR（可重复读）两种事务隔离时，执行select操作会访问版本链实现不同事务的读写，写读并发执行。

### 连接方式
左联：以左表当作标准，在右边选择符合条件的，如果油表不存在，连接后设置未空<br>
### 三大范式
第一大：原子性：属性不应该是可分的。<br>
第二：唯一性： 消除非主键元素部分依赖于联合主键中的部分字段<br>
第三：独立性 ，在 2NF 的基础上，非主属性不传递依赖于主属性
### 说说索引
索引就是为了快速寻找一些具有特定值的列，如果没有
### InnoDB的索引使用的是B+树实现，B+树对比B树的好处：
IO次数少：B+树的中间结点只存放索引，数据都存在叶结点中，因此中间结点可以存更多的数据，让索引树更加矮胖；<br>
范围查询效率更高：B树需要中序遍历整个树，只B+树需要遍历叶结点中的链表；<br>
查询效率更加稳定：每次查询都需要从根结点到叶结点，路径长度相同，所以每次查询的效率都差不多
### 设计原则
1.适合索引的列出现在where子句里面
2.基类较小的类，没必要建立索引
3.更新频繁的不需要建立索引
4.不要过度建立索引
### 索引失效的场景
1.使用组合索引时，需要遵循“最左前缀”原则<br>
2.LIKE以通配符开头（%abc）MySQL索引会失效变成全表扫描的操作；<br>
3.少用or，用它来连接时会索引失效<br>
4.部分函数的使用可能会导致失效。
### 聚集索引和非聚集索引
聚簇索引是根据主键创建的一棵B+树，聚簇索引的叶子节点存放了表中的所有记录。
辅助索引是根据索引键创建的一棵B+树，与聚簇索引不同的是，其叶子节点仅存放索引键值，以及该索引键值指向的主键。
也就是说，如果通过辅助索引来查找数据，那么当找到辅助索引的叶子节点后，很有可能还需要根据主键值查找聚簇索引来得到数据，
### 持久化策略
AOF 将数据库的每次操作以日志的形式记录下来
RDB： 每间隔一段时间，将内存中的数据集快照写入磁盘（fork 一个子进程，先将数据写入临时文件，写入成功后，再替换原文件）
### 慢查询的优化
1.数据过多的化，分库分表
2.没有索引，建立索引，有索引的化，优化索引。
